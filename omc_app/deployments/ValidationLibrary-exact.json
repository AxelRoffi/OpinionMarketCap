{
  "language": "Solidity",
  "sources": {
    "contracts/active/libraries/ValidationLibrary.sol": {
      "content": "// libraries/ValidationLibrary.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nlibrary ValidationLibrary {\n    // Validate opinion creation parameters\n    function validateOpinionParams(\n        string memory question,\n        string memory initialAnswer,\n        uint256 maxQuestionLength,\n        uint256 maxAnswerLength\n    ) public pure {\n        bytes memory questionBytes = bytes(question);\n        bytes memory answerBytes = bytes(initialAnswer);\n\n        if (questionBytes.length < 2 || answerBytes.length < 2)\n            revert(\"Minimum 2 characters required\");\n        if (questionBytes.length > maxQuestionLength)\n            revert(\"Question too long\");\n        if (answerBytes.length > maxAnswerLength) revert(\"Answer too long\");\n    }\n\n    // Validate parameter update with bounds\n    function validateParameterUpdate(\n        uint256 value,\n        uint256 maxValue,\n        uint256 lastUpdateTime,\n        uint256 cooldownPeriod,\n        uint256 blockTimestamp\n    ) public pure {\n        // Check value is within bounds\n        if (value > maxValue) revert(\"Value exceeds maximum\");\n\n        // Check cooldown period has elapsed\n        if (lastUpdateTime + cooldownPeriod > blockTimestamp)\n            revert(\"Cooldown not elapsed\");\n    }\n\n    // Check if address is valid (non-zero)\n    function validateAddress(address addr) public pure {\n        if (addr == address(0)) revert(\"Zero address not allowed\");\n    }\n\n    // Validate transaction rate limit\n    function validateRateLimit(\n        uint256 userLastBlock,\n        uint256 userTradesInBlock,\n        uint256 maxTradesPerBlock,\n        uint256 blockNumber\n    ) public pure returns (uint256 newTradesInBlock) {\n        if (userLastBlock != blockNumber) {\n            // First trade in this block\n            return 1;\n        } else {\n            // Increment trade count\n            newTradesInBlock = userTradesInBlock + 1;\n\n            // Check if exceeds limit\n            if (newTradesInBlock > maxTradesPerBlock)\n                revert(\"Max trades per block exceeded\");\n\n            return newTradesInBlock;\n        }\n    }\n\n    /**\n     * @dev Validates answer description (optional, configurable max chars)\n     * @param description Answer description (can be empty string)\n     * @param maxLength Maximum allowed length for description\n     */\n    function validateDescription(string memory description, uint256 maxLength) public pure {\n        bytes memory descriptionBytes = bytes(description);\n        \n        // If description is provided, must be at least 2 characters\n        if (descriptionBytes.length > 0 && descriptionBytes.length < 2) {\n            revert(\"Description minimum 2 characters\");\n        }\n        // Check maximum length\n        if (descriptionBytes.length > maxLength) revert(\"Description too long\");\n    }\n\n    /**\n     * @dev Validates answer description (backward compatibility - deprecated)\n     * @param description Answer description (can be empty string)\n     */\n    function validateDescription(string memory description) public pure {\n        bytes memory descriptionBytes = bytes(description);\n        \n        // If description is provided, must be at least 2 characters\n        if (descriptionBytes.length > 0 && descriptionBytes.length < 2) {\n            revert(\"Description minimum 2 characters\");\n        }\n        // Check maximum length\n        if (descriptionBytes.length > 120) revert(\"Description too long\");\n    }\n\n    /**\n     * @dev Validates opinion categories against available categories (configurable max)\n     * @param userCategories Categories selected by user \n     * @param availableCategories Global available categories array\n     * @param maxCategoriesAllowed Maximum number of categories allowed per opinion\n     */\n    function validateOpinionCategories(\n        string[] memory userCategories,\n        string[] storage availableCategories,\n        uint256 maxCategoriesAllowed\n    ) public view {\n        uint256 userLength = userCategories.length;\n        \n        // 1. Length validation\n        if (userLength == 0) revert(\"NoCategoryProvided\");\n        if (userLength > maxCategoriesAllowed) revert(\"TooManyCategories\");\n        \n        // 2. Duplicate check - OPTIMIZED for gas in creative freedom zone\n        for (uint256 i = 0; i < userLength; i++) {\n            for (uint256 j = i + 1; j < userLength; j++) {\n                if (keccak256(bytes(userCategories[i])) == keccak256(bytes(userCategories[j]))) {\n                    revert(\"DuplicateCategory\");\n                }\n            }\n        }\n        \n        // 3. Existence check - OPTIMIZED for gas in creative freedom zone\n        uint256 availableLength = availableCategories.length;\n        for (uint256 i = 0; i < userLength; i++) {\n            bool found = false;\n            bytes32 userCatHash = keccak256(bytes(userCategories[i]));\n            \n            for (uint256 j = 0; j < availableLength; j++) {\n                if (userCatHash == keccak256(bytes(availableCategories[j]))) {\n                    found = true;\n                    break; // Gas optimization: early exit\n                }\n            }\n            \n            if (!found) revert(\"InvalidCategory\");\n        }\n    }\n\n    /**\n     * @dev Validates opinion categories against available categories (backward compatibility)\n     * @param userCategories Categories selected by user (1-3 required)\n     * @param availableCategories Global available categories array\n     * ðŸš¨ IMPOSED SIGNATURE - DO NOT MODIFY\n     */\n    function validateOpinionCategories(\n        string[] memory userCategories,\n        string[] storage availableCategories\n    ) public view {\n        uint256 userLength = userCategories.length;\n        \n        // 1. Length validation - IMPOSED ORDER\n        if (userLength == 0) revert(\"NoCategoryProvided\");\n        if (userLength > 3) revert(\"TooManyCategories\");\n        \n        // 2. Duplicate check - OPTIMIZED for gas in creative freedom zone\n        for (uint256 i = 0; i < userLength; i++) {\n            for (uint256 j = i + 1; j < userLength; j++) {\n                if (keccak256(bytes(userCategories[i])) == keccak256(bytes(userCategories[j]))) {\n                    revert(\"DuplicateCategory\");\n                }\n            }\n        }\n        \n        // 3. Existence check - OPTIMIZED for gas in creative freedom zone\n        uint256 availableLength = availableCategories.length;\n        for (uint256 i = 0; i < userLength; i++) {\n            bool found = false;\n            bytes32 userCatHash = keccak256(bytes(userCategories[i]));\n            \n            for (uint256 j = 0; j < availableLength; j++) {\n                if (userCatHash == keccak256(bytes(availableCategories[j]))) {\n                    found = true;\n                    break; // Gas optimization: early exit\n                }\n            }\n            \n            if (!found) revert(\"InvalidCategory\");\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "viaIR": true,
    "metadata": {
      "bytecodeHash": "none"
    },
    "debug": {
      "revertStrings": "strip"
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
