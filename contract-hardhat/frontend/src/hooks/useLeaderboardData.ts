'use client';

import { useMemo } from 'react';
import { useReadContract } from 'wagmi';
import { CONTRACTS, OPINION_CORE_ABI, FEE_MANAGER_ABI } from '@/lib/contracts';
import { useAllOpinions } from '@/hooks/useAllOpinions';

export interface LeaderboardUser {
  address: string;
  username?: string;
  questionsCreated: number;
  opinionsOwned: number;
  creatorFees: number; // 3% fees earned from questions they created (real calculated amount)
  tradingFees: number; // Fees earned from trading/owning answers (accumulated fees from FeeManager)
  tvl: number; // Total Value Locked - current portfolio value (unrealized gains)
  creationCosts: number; // Total costs paid for creating questions (5 USDC each)
  trueROI: number; // ROI based only on realized earnings vs costs (excludes TVL)
  poolsContributed: number; // TODO: Implement when pool integration ready
  tradesCount: number; 
  rank: number;
  // Legacy field for backward compatibility
  totalEarnings: number; // creatorFees + tradingFees
  realizedEarnings: number; // Same as totalEarnings
}

interface LeaderboardStats {
  totalUsers: number;
  totalVolume: number; // USDC
  totalQuestions: number;
  totalTrades: number;
}

// Hook to get next opinion ID (total questions created)
function useNextOpinionId() {
  return useReadContract({
    address: CONTRACTS.OPINION_CORE,
    abi: OPINION_CORE_ABI,
    functionName: 'nextOpinionId',
    query: {
      staleTime: 30000, // Cache for 30 seconds
      refetchInterval: 60000, // Refetch every minute
    },
  });
}



// Main hook for leaderboard data
export function useLeaderboardData() {
  const { data: nextOpinionIdData, isLoading: isLoadingCount } = useNextOpinionId();
  const totalOpinions = nextOpinionIdData ? Number(nextOpinionIdData) : 0;
  
  // Use the existing useAllOpinions hook for consistency
  const { opinions } = useAllOpinions();
  const isLoadingOpinions = false; // useAllOpinions handles its own loading

  // Calculate leaderboard data from blockchain
  const leaderboardData = useMemo(() => {
    if (!opinions || opinions.length === 0) {
      return { users: [], stats: { totalUsers: 0, totalVolume: 0, totalQuestions: 0, totalTrades: 0 } };
    }

    // Extract unique users and calculate their actual trading data
    const userMap = new Map<string, {
      address: string;
      questionsCreated: number;
      opinionsOwned: number;
      creatorFeesEarned: number;   // 3% fees earned from questions they created
      tvl: number;                 // Current portfolio value (sum of owned opinion prices)
      creationCosts: number;       // Total costs paid for creating questions (5 USDC each)
      totalVolumeGenerated: number; // Total volume generated by their questions
      tradesCount: number;
    }>();

    let totalVolume = 0;
    let totalTrades = 0;

    opinions.forEach((opinion) => {
      if (!opinion || !opinion.creator) return;

      try {
        const creator = opinion.creator.toLowerCase();
        const currentOwner = opinion.currentAnswerOwner?.toLowerCase();
        const opinionVolume = opinion.totalVolume ? Number(opinion.totalVolume) / 1e6 : 0; // Convert from wei to USDC
        const lastPrice = opinion.lastPrice ? Number(opinion.lastPrice) / 1e6 : 0;
        const nextPrice = opinion.nextPrice ? Number(opinion.nextPrice) / 1e6 : 0;
      
      totalVolume += opinionVolume;
      totalTrades += 1; // Each opinion represents at least one trade

      // Track creator - they pay creation costs and earn 3% fees on all trading
      if (!userMap.has(creator)) {
        userMap.set(creator, {
          address: creator,
          questionsCreated: 0,
          opinionsOwned: 0,
          creatorFeesEarned: 0,
          tvl: 0,
          creationCosts: 0,
          totalVolumeGenerated: 0,
          tradesCount: 0,
        });
      }
      const creatorData = userMap.get(creator)!;
      creatorData.questionsCreated += 1;
      
      // Creation costs: 5 USDC per question created (cost to user)
      creatorData.creationCosts += 5; // 5 USDC creation cost per question
      
      // Creator fees earned: 3% of ALL trading volume on their questions
      creatorData.creatorFeesEarned += opinionVolume * 0.03; // 3% creator fee from contract
      creatorData.totalVolumeGenerated += opinionVolume;
      creatorData.tradesCount += 1;

      // Track current answer owner - they have TVL (Total Value Locked)
      if (currentOwner && currentOwner !== creator) {
        if (!userMap.has(currentOwner)) {
          userMap.set(currentOwner, {
            address: currentOwner,
            questionsCreated: 0,
            opinionsOwned: 0,
            creatorFeesEarned: 0,
            tvl: 0,
            creationCosts: 0,
            totalVolumeGenerated: 0,
            tradesCount: 0,
          });
        }
        const ownerData = userMap.get(currentOwner)!;
        ownerData.opinionsOwned += 1;
        
        // TVL: Current market value of the opinion they own
        ownerData.tvl += nextPrice; // Current market value
        ownerData.tradesCount += 1;
      }

      // IMPORTANT: Track ALL historical traders by analyzing trading volume
      // If there's trading volume, someone other than creator must have traded
      if (opinionVolume > 0) {
        // Estimate number of unique traders based on volume and price patterns
        // This is a heuristic since we don't have event logs
        const avgTradeSize = (lastPrice + nextPrice) / 2;
        const estimatedTrades = Math.max(1, Math.floor(opinionVolume / avgTradeSize));
        
        // Add trading activity to both creator and current owner
        if (creator) {
          const creatorData = userMap.get(creator);
          if (creatorData) {
            creatorData.tradesCount = Math.max(creatorData.tradesCount, estimatedTrades);
          }
        }
        
        if (currentOwner && currentOwner !== creator) {
          const ownerData = userMap.get(currentOwner);
          if (ownerData) {
            ownerData.tradesCount = Math.max(ownerData.tradesCount, estimatedTrades);
          }
        }
        
        totalTrades += estimatedTrades;
      }
      } catch (error) {
        console.error('Error processing opinion:', opinion.id, error);
        // Continue processing other opinions
      }
    });

    // Convert to leaderboard format with corrected earnings calculation
    const users: LeaderboardUser[] = Array.from(userMap.values()).map((userData, index) => {
      try {
        // CREATOR FEES: Real calculated amount based on 3% of volume they generated
        const creatorFees = userData.creatorFeesEarned || 0;
        
        // TRADING FEES: Will be populated from FeeManager accumulated fees (0 for now)
        const tradingFees = 0; // Will be enhanced with real accumulated fees later
        
        // TOTAL REALIZED EARNINGS: Creator fees + Trading fees (actual money earned)
        const totalEarnings = creatorFees + tradingFees;
        
        // SIMPLIFIED ROI CALCULATION (EXCLUDES TVL AND CREATION COSTS):
        // ROI = Pure earnings performance (no costs or unrealized gains)
        // This shows earning efficiency: earnings as % of trading volume generated
        const creationCosts = userData.creationCosts || 0;
        
        // ROI = Earnings Rate (what % of volume became earnings)
        const volumeGenerated = userData.totalVolumeGenerated || 0;
        const trueROI = volumeGenerated > 0 ? (totalEarnings / volumeGenerated) * 100 : 0;

        return {
          address: userData.address || '',
          username: undefined, // Could be enhanced with ENS lookup
          questionsCreated: userData.questionsCreated || 0,
          opinionsOwned: userData.opinionsOwned || 0,
          creatorFees: creatorFees, // Real 3% fees earned from created questions
          tradingFees: tradingFees, // Accumulated fees from FeeManager (0 for now)
          tvl: userData.tvl || 0, // Current portfolio value (unrealized gains)
          creationCosts: creationCosts, // Costs paid for creating questions
          trueROI: isFinite(trueROI) ? trueROI : 0, // ROI excluding TVL (only realized earnings)
          poolsContributed: 0, // TODO: Implement when pool data is available
          tradesCount: userData.tradesCount || 0,
          rank: index + 1, // Will be properly calculated after sorting
          // Legacy fields for backward compatibility
          totalEarnings: totalEarnings,
          realizedEarnings: totalEarnings,
        };
      } catch (error) {
        console.error('Error creating user data for:', userData.address, error);
        // Return default user data on error
        return {
          address: userData.address || '',
          username: undefined,
          questionsCreated: 0,
          opinionsOwned: 0,
          creatorFees: 0,
          tradingFees: 0,
          tvl: 0,
          creationCosts: 0,
          trueROI: 0,
          poolsContributed: 0,
          tradesCount: 0,
          rank: index + 1,
          totalEarnings: 0,
          realizedEarnings: 0,
        };
      }
    });

    // Sort by True ROI (descending) - shows best performing users
    users.sort((a, b) => b.trueROI - a.trueROI);
    
    // Update ranks based on earnings
    users.forEach((user, index) => {
      user.rank = index + 1;
    });

    const stats: LeaderboardStats = {
      totalUsers: users.length,
      totalVolume: totalVolume,
      totalQuestions: totalOpinions - 1, // Subtract 1 because opinions start at ID 1
      totalTrades: totalTrades,
    };

    return { users, stats };
  }, [opinions, totalOpinions]);

  return {
    users: leaderboardData.users,
    stats: leaderboardData.stats,
    isLoading: isLoadingCount || isLoadingOpinions,
    totalOpinions,
  };
}

// Enhanced hook that fetches real trading fees for top users
export function useEnhancedLeaderboardData() {
  const baseData = useLeaderboardData();

  // Get first few users to fetch their trading fees
  const firstUser = baseData.users[0];
  const secondUser = baseData.users[1];
  const thirdUser = baseData.users[2];

  // Fetch trading fees (accumulated fees) for top 3 users
  const firstUserTradingFees = useReadContract({
    address: CONTRACTS.FEE_MANAGER,
    abi: FEE_MANAGER_ABI,
    functionName: 'getAccumulatedFees',
    args: firstUser ? [firstUser.address as `0x${string}`] : undefined,
    query: {
      enabled: Boolean(firstUser),
      staleTime: 30000,
    },
  });

  const secondUserTradingFees = useReadContract({
    address: CONTRACTS.FEE_MANAGER,
    abi: FEE_MANAGER_ABI,
    functionName: 'getAccumulatedFees',
    args: secondUser ? [secondUser.address as `0x${string}`] : undefined,
    query: {
      enabled: Boolean(secondUser),
      staleTime: 30000,
    },
  });

  const thirdUserTradingFees = useReadContract({
    address: CONTRACTS.FEE_MANAGER,
    abi: FEE_MANAGER_ABI,
    functionName: 'getAccumulatedFees',
    args: thirdUser ? [thirdUser.address as `0x${string}`] : undefined,
    query: {
      enabled: Boolean(thirdUser),
      staleTime: 30000,
    },
  });

  // Enhanced users with real trading fees
  const enhancedUsers = useMemo(() => {
    if (!baseData.users || baseData.users.length === 0) {
      return baseData.users;
    }

    return baseData.users.map(user => {
      let realTradingFees = 0;

      // Get real trading fees for top 3 users
      if (firstUser && user.address.toLowerCase() === firstUser.address.toLowerCase()) {
        realTradingFees = firstUserTradingFees.data ? Number(firstUserTradingFees.data) / 1e6 : 0;
      } else if (secondUser && user.address.toLowerCase() === secondUser.address.toLowerCase()) {
        realTradingFees = secondUserTradingFees.data ? Number(secondUserTradingFees.data) / 1e6 : 0;
      } else if (thirdUser && user.address.toLowerCase() === thirdUser.address.toLowerCase()) {
        realTradingFees = thirdUserTradingFees.data ? Number(thirdUserTradingFees.data) / 1e6 : 0;
      }

      // Update trading fees with real data
      const updatedUser = {
        ...user,
        tradingFees: realTradingFees,
        totalEarnings: user.creatorFees + realTradingFees,
        realizedEarnings: user.creatorFees + realTradingFees,
      };

      // Recalculate True ROI with updated total earnings using actual volume data
      const actualVolumeGenerated = user.creatorFees > 0 ? user.creatorFees / 0.03 : 0; // Reverse calculate from creator fees
      updatedUser.trueROI = actualVolumeGenerated > 0 ? (updatedUser.totalEarnings / actualVolumeGenerated) * 100 : 0;

      return updatedUser;
    }).sort((a, b) => b.trueROI - a.trueROI) // Re-sort by True ROI
      .map((user, index) => ({ ...user, rank: index + 1 })); // Update ranks
  }, [
    baseData.users,
    firstUser, secondUser, thirdUser,
    firstUserTradingFees.data, secondUserTradingFees.data, thirdUserTradingFees.data
  ]);

  const isLoadingFees = firstUserTradingFees.isLoading || secondUserTradingFees.isLoading || thirdUserTradingFees.isLoading;

  return {
    users: enhancedUsers,
    stats: baseData.stats,
    isLoading: baseData.isLoading || isLoadingFees,
    totalOpinions: baseData.totalOpinions,
  };
}